// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleNodeJSEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=d_39bb39108d
ROOST_METHOD_SIG_HASH=d_72e6da76f1


*/

// ********RoostGPT********
// Import the dependencies
const bootstrap = require("../js/bootstrap.min.js");

// Define the test suite
describe("d function in bootstrap.min.js", () => {

  // Mocking the dependencies
  let mockDetach, mockTrigger, mockRemoveAttr, mockElement;

  // Setup before each test case
  beforeEach(() => {
    mockDetach = jest.fn();
    mockTrigger = jest.fn();
    mockRemoveAttr = jest.fn();
    mockElement = {
      detach: mockDetach,
      trigger: mockTrigger,
      removeAttr: mockRemoveAttr,
    };
    bootstrap.e = {
      hoverState: 'out',
      $element: mockElement,
      type: 'tooltip',
    };
    bootstrap.b = jest.fn();
  });

  // Test case 1: Check if 'detach' is called when hoverState is not 'in'
  test("should call 'detach' when hoverState is not 'in'", () => {
    bootstrap.d();
    expect(mockDetach).toHaveBeenCalled();
  });

  // Test case 2: Check if 'removeAttr' and 'trigger' are called with correct arguments
  test("should call 'removeAttr' and 'trigger' with correct arguments", () => {
    bootstrap.d();
    expect(mockRemoveAttr).toHaveBeenCalledWith('aria-describedby');
    expect(mockTrigger).toHaveBeenCalledWith('hidden.bs.tooltip');
  });

  // Test case 3: Check if 'b' is called when 'b' is truthy
  test("should call 'b' when 'b' is truthy", () => {
    bootstrap.b = jest.fn(() => true);
    bootstrap.d();
    expect(bootstrap.b).toHaveBeenCalled();
  });

  // Test case 4: Check if 'b' is not called when 'b' is falsy
  test("should not call 'b' when 'b' is falsy", () => {
    bootstrap.b = jest.fn(() => false);
    bootstrap.d();
    expect(bootstrap.b).not.toHaveBeenCalled();
  });

});
