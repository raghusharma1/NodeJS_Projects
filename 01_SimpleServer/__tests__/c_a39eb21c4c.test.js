// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleNodeJSEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=c_e5ad5cd4a4
ROOST_METHOD_SIG_HASH=c_a39eb21c4c


*/

// ********RoostGPT********
// Importing the required dependencies
const { c } = require('../js/bootstrap.min.js');

describe('bootstrap.min.js', () => {

  // Setting up the mock functions for the dependencies
  let mockData;
  beforeEach(() => {
    mockData = jest.fn();
    global.a = jest.fn(() => ({
      this: [],
      data: mockData,
    }));
    global.b = jest.fn();
  });

  test('The function "c" should call the "each" method with a function as argument', () => {
    const mockEach = jest.fn();
    global.a().this.each = mockEach;
    c('test');
    expect(mockEach).toHaveBeenCalled();
  });

  test('The function "c" should create a new "b" instance if "e" is undefined', () => {
    mockData.mockReturnValueOnce(undefined);
    c('test');
    expect(global.b).toHaveBeenCalled();
  });

  test('The function "c" should not create a new "b" instance if "e" is already defined', () => {
    mockData.mockReturnValueOnce({});
    c('test');
    expect(global.b).not.toHaveBeenCalled();
  });

  test('The function "c" should call the method named by the string "c" if it exists on "e"', () => {
    const mockMethod = jest.fn();
    mockData.mockReturnValueOnce({
      test: mockMethod,
    });
    c('test');
    expect(mockMethod).toHaveBeenCalled();
  });

  test('The function "c" should not throw an error if the method named by the string "c" does not exist on "e"', () => {
    mockData.mockReturnValueOnce({});
    expect(() => {
      c('test');
    }).not.toThrow();
  });

});
