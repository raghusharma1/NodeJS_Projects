// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleNodeJSEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=c_e5ad5cd4a4
ROOST_METHOD_SIG_HASH=c_a39eb21c4c


*/

// ********RoostGPT********
// Import the function to be tested
const c = require('../js/bootstrap.min.js').c;

describe('c method in bootstrap.min.js', () => {
  // Set up
  let mockData;

  beforeEach(() => {
    // Mock data object with data method
    mockData = {
      data: jest.fn().mockImplementation((key, val) => {
        if (val) {
          mockData[key] = val;
        }
        return mockData[key];
      })
    };

    // Mock each method
    global.each = jest.fn((callback) => {
      callback();
    });

    // Mock the a function
    global.a = jest.fn().mockReturnValue(mockData);
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  test('should execute without any errors', () => {
    const b = jest.fn();
    c.call([{}], 'test');
    expect(global.a).toHaveBeenCalled();
    expect(mockData.data).toHaveBeenCalled();
    expect(b).not.toHaveBeenCalled();
  });

  test('should create new instance of b when not exists', () => {
    const b = jest.fn();
    c.call([{}], {});
    expect(global.a).toHaveBeenCalled();
    expect(mockData.data).toHaveBeenCalledTimes(2);
    expect(b).toHaveBeenCalled();
  });

  test('should call method on existing instance of b', () => {
    const b = jest.fn().mockImplementation(() => {
      return {
        test: jest.fn()
      };
    });
    mockData.data('bs.scrollspy', new b());
    c.call([{}], 'test');
    expect(global.a).toHaveBeenCalled();
    expect(mockData.data).toHaveBeenCalled();
    expect(b).not.toHaveBeenCalled();
    expect(b.prototype.test).toHaveBeenCalled();
  });

  test('should throw error when method does not exist on instance of b', () => {
    const b = jest.fn().mockImplementation(() => {
      return {};
    });
    mockData.data('bs.scrollspy', new b());
    expect(() => {
      c.call([{}], 'test');
    }).toThrow();
  });
});
