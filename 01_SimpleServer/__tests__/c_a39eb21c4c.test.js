// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleNodeJSEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=c_e5ad5cd4a4
ROOST_METHOD_SIG_HASH=c_a39eb21c4c


*/

// ********RoostGPT********
// Importing necessary modules
const bootstrap = require('../js/bootstrap.min');

describe('Method: c(c)', () => {
  let data;

  // Setup before each test
  beforeEach(() => {
    data = {
      bs: {
        scrollspy: {}
      }
    };
  });

  // Cleanup after each test
  afterEach(() => {
    data = null;
  });

  // Test case 1: Check if method c(c) creates a new instance of b when e is not defined
  test('should create a new instance of b when e is not defined', () => {
    const spy = jest.spyOn(bootstrap, 'b');
    bootstrap.c.call({ each: jest.fn().mockImplementation((cb) => cb()) }, data);
    expect(spy).toHaveBeenCalled();
    spy.mockRestore();
  });

  // Test case 2: Check if method c(c) does not create a new instance of b when e is defined
  test('should not create a new instance of b when e is defined', () => {
    data.bs.scrollspy = new bootstrap.b();
    const spy = jest.spyOn(bootstrap, 'b');
    bootstrap.c.call({ each: jest.fn().mockImplementation((cb) => cb()) }, data);
    expect(spy).not.toHaveBeenCalled();
    spy.mockRestore();
  });

  // Test case 3: Check if method c(c) calls the function e[c]() when c is a string
  test('should call the function e[c]() when c is a string', () => {
    data.bs.scrollspy['test'] = jest.fn();
    bootstrap.c.call({ each: jest.fn().mockImplementation((cb) => cb()) }, 'test');
    expect(data.bs.scrollspy['test']).toHaveBeenCalled();
  });

  // Test case 4: When c is not a string, e[c]() should not be called
  test('should not call the function e[c]() when c is not a string', () => {
    data.bs.scrollspy['test'] = jest.fn();
    bootstrap.c.call({ each: jest.fn().mockImplementation((cb) => cb()) }, 123);
    expect(data.bs.scrollspy['test']).not.toHaveBeenCalled();
  });
});
