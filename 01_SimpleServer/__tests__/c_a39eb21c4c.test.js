// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleNodeJSEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=c_e5ad5cd4a4
ROOST_METHOD_SIG_HASH=c_a39eb21c4c


*/

// ********RoostGPT********
// Import the function to be tested
const c = require('../js/bootstrap.min.js').c;

describe('c method in bootstrap.min.js', () => {
  // Mock the dependencies
  const mockEach = jest.fn((callback) => callback());
  const mockData = jest.fn();
  const mockA = jest.fn(() => ({ each: mockEach, data: mockData }));
  const mockNewB = jest.fn();

  beforeEach(() => {
    // Reset the mocks before each test
    mockEach.mockClear();
    mockData.mockClear();
    mockA.mockClear();
    mockNewB.mockClear();
  });

  test('should call each function with provided callback', () => {
    c.call({ each: mockEach }, 'test');
    expect(mockEach).toHaveBeenCalled();
  });

  test('should call data function with "bs.scrollspy"', () => {
    mockData.mockReturnValueOnce('existing-data');
    c.call({ each: mockEach }, 'test');
    const callback = mockEach.mock.calls[0][0];
    callback.call({ data: mockData });
    expect(mockData).toHaveBeenCalledWith('bs.scrollspy');
  });

  test('should call new B function if data function returns falsy value', () => {
    mockData.mockReturnValueOnce(undefined);
    mockNewB.mockReturnValueOnce('new-data');
    c.call({ each: mockEach }, { newB: mockNewB });
    const callback = mockEach.mock.calls[0][0];
    callback.call({ data: mockData });
    expect(mockNewB).toHaveBeenCalled();
  });

  test('should not call new B function if data function returns truthy value', () => {
    mockData.mockReturnValueOnce('existing-data');
    c.call({ each: mockEach }, { newB: mockNewB });
    const callback = mockEach.mock.calls[0][0];
    callback.call({ data: mockData });
    expect(mockNewB).not.toHaveBeenCalled();
  });
});
